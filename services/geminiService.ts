import { GoogleGenAI, Type } from "@google/genai";
import { ArchiveMetadata } from "../types";

// Initialize Gemini
// NOTE: We assume process.env.API_KEY is available.
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

/**
 * Helper to deeply clean text artifacts.
 * Handles URI decoding (recursive), underscores, and extra whitespace.
 */
const cleanText = (text: string): string => {
  if (!text) return "";
  
  let clean = text;
  
  // Helper for safe decoding that won't throw on malformed sequences
  const safeDecode = (s: string) => {
      // First try standard decode
      try {
          return decodeURIComponent(s);
      } catch (e) {
          // If that fails, try replacing specific encoded sequences
          return s.replace(/%[0-9A-F]{2}/gi, (match) => {
              try { return decodeURIComponent(match); } catch { return match; }
          });
      }
  };
  
  // 1. Recursive URI Decode
  // Sometimes text is double encoded or has mixed artifacts
  let previous = "";
  let loopCount = 0;
  while (clean !== previous && loopCount < 3) {
      previous = clean;
      if (/%[0-9A-F]{2}/i.test(clean)) {
          clean = safeDecode(clean);
      }
      loopCount++;
  }

  // 2. Replace Underscores
  // If the text has underscores but NO spaces, it's likely a filename_style_string.
  if (clean.includes('_') && !clean.includes(' ')) {
      clean = clean.replace(/_/g, ' ');
  }

  // 3. Normalize Whitespace
  clean = clean.replace(/\s+/g, ' ').trim();

  return clean;
};

/**
 * Deeply cleans a filename to be used as a title candidate.
 * Fixes %20, underscores, and extension artifacts.
 */
const formatFilename = (filename: string): string => {
    try {
        let name = filename;
        // 1. Decode URI components (fixes %20, %3A, etc.)
        try { name = decodeURIComponent(name); } catch {}
        // 2. Remove file extension
        name = name.replace(/\.[^/.]+$/, "");
        // 3. Replace underscores, hyphens, and periods with spaces
        name = name.replace(/[_\-\.]/g, " ");
        // 4. Collapse multiple spaces into one
        name = name.replace(/\s+/g, " ").trim();
        return name;
    } catch {
        return filename;
    }
}

export const generateMetadataFromContext = async (
  filename: string,
  userContext: string
): Promise<ArchiveMetadata> => {
  const cleanName = formatFilename(filename);

  try {
    // We explicitly ask Gemini to research the URL if provided.
    // Note: Private URLs (like notebooklm.google.com) cannot be crawled, 
    // so we encourage the user to paste source URLs.
    
    // We present the cleaned name as the primary identifier to avoid biasing Gemini with URL-encoded garbage.
    const prompt = `
      I have an audio file.
      
      Suggested Title: "${cleanName}"
      Original Filename (Reference only): "${filename}"
      User Context: "${userContext || "This is an audio discussion or podcast generated by NotebookLM."}"
      
      Task: Generate clean, professional metadata for the Internet Archive.
      
      CRITICAL INSTRUCTIONS:
      1. OUTPUT MUST BE HUMAN READABLE PLAIN TEXT. 
      2. ABSOLUTELY NO URL ENCODING (e.g. do not use %20, %3A, etc). Use spaces.
      3. Do not use underscores (_) instead of spaces.
      4. The "Suggested Title" is likely the best starting point. Fix capitalization and grammar if needed.
      5. If the User Context contains a URL (Wikipedia, News, etc.), USE GOOGLE SEARCH to research the topic.
      6. Write a DETAILED, rich description (3-5 sentences) about the content in NATURAL LANGUAGE.
      7. DO NOT include raw URLs, links, or "Research Sources" sections in the description.
      
      Output Schema:
      - title: Clean, formatted string (No %20).
      - description: Detailed summary in plain English (No URLs).
      - tags: Array of strings (lowercase, no %20).
    `;

    const response = await ai.models.generateContent({
      model: "gemini-3-flash-preview",
      contents: prompt,
      config: {
        tools: [{ googleSearch: {} }],
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            title: { type: Type.STRING },
            description: { type: Type.STRING },
            tags: {
              type: Type.ARRAY,
              items: { type: Type.STRING },
            },
          },
          required: ["title", "description", "tags"],
        },
      },
    });

    const text = response.text;
    if (!text) throw new Error("No response from Gemini");

    const json = JSON.parse(text);
    
    // Aggressively clean the output
    let title = cleanText(json.title);
    let description = cleanText(json.description);
    
    // Sort and clean tags
    let tags = json.tags || [];
    if (Array.isArray(tags)) {
        tags = tags.map((t: string) => cleanText(t));
        // Remove duplicates and sort
        tags = Array.from(new Set(tags)).sort((a: string, b: string) => a.localeCompare(b));
    }

    // NOTE: We intentionally do NOT append groundingChunks (URLs) to the description
    // to keep the output clean and natural language only, as requested.

    return {
      title: title,
      description: description,
      tags: tags,
      creator: "NotebookLM", // Default creator
    };
  } catch (error) {
    console.error("Gemini Metadata Generation Error:", error);
    // Fallback if Gemini fails
    return {
      title: cleanName,
      description: "Audio uploaded from NotebookLM. (Metadata generation failed)",
      tags: ["ai-generated", "notebooklm", "podcast"].sort(),
      creator: "NotebookLM",
    };
  }
};